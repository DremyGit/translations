# Immutable.js介绍与函数式编程概念

> 原文[Introduction to Immutable.js and Functional Programming Concepts](https://auth0.com/blog/2016/03/23/intro-to-immutable-js/)，作者Sebastián Peyrott

这几年函数式编程逐渐火了起来。例如Clojure、Scala和Haskell这些编程语言已经吸引了很多对新技术着迷的程序员们的眼球，因为他们在某些方面有着巨大的优势。`Immutable.js`的目标是把其中的一些优势通过简单直观的API带到Javascript中来。请跟着我们通过这篇文章来学习这些（benefits）并运用到你的项目中。

## 介绍：不可变（immutability）和Immutable.js

尽管函数式编程的特变不仅仅在于其不可变，但很多的函数式语言都把不可变作为一个重点。例如Clojure和Haskell，都对数据如何改变和何时能够改变做出了严格的编译时限制。正因这一点，许多开发者便放弃了这些语言。对于那些能够忍受住最初的煎熬的人们来说，解决问题的新方式开始变得多样起来。特别是对于初次接触的人来说，数据结构是函数式范式的主要的争议点。

在这篇文章的末尾，是关于可变与不可变数据结构的比较，充满了冷酷的、复杂的数学概念。让逻辑分析告诉我们到底是哪一种数据结构最适合处理哪些问题。然而仅通过语言自身的支持来帮助实现这些数据结构可能会绕一段远路。集合了多范式语言优点的Javascript语言，为可变和不可变数据结构都提供了一个方便的平台。其它的一些语言，比如C语言，虽然也能够实现不可变数据结构，但是，这个语言本身的限制让这样变得很笨重。

那么到底什么是“变化(mutation)”呢？对于数据或者数据结构来说，“变化”是它们的一种内在的改变。而对于不可变来说，在改变之前必须要先对目标数据或者数据结构做一份拷贝

![immutablejs_tree](https://cdn.auth0.com/blog/immutablejs/tree.svg)

那么函数是数据结构的信条是什么呢？是什么使得不可变如此重要？它们的正确使用方式是什么？这些问题我们下边会提到。

> 注意：你可能在你的Javascript代码中已经使用了某个函数式编程语言的结构，但是你可能并不知道这一点。举个例子，`Array.map`通过对一个数组中的每一个元素提供一个函数，然后返回一个新的数组，但在这个过程中不会修改原始数据。函数式编程喜欢使用一等(first-class)函数，它们能被传入到别的函数中，并且返回已存在数据的新版本，这实际上就是`Array.map`所做的工作。这种处理数据的方式也喜欢函数式编程中的另一个核心概念——组合。

## 核心内容

这些是函数式编程的核心内容，通过这篇文章，你会知道这些概念如何适用在Immutable.js和其他的函数式类库的设计和使用之中的。

### 不可变

不可变是指在数据（和管理它的数据结构）被实例化之后，**不允许“变化”发生**。在实践中，“变化”能够分为两派：可见变化和不可见变化。**可见变化**是指那些可以被**外部观察者**通过API记录下来的，数据或者数据结构的变化。相对的，**不可见变化**是指那些不能够被外部观察者通过API（缓存数据结构是一个很好的例子）。在某种意义上，不可见变化能看作是一种副作用（我们将会在下面提到并解释这个概念）。函数式编程的上下文中，不可变通常不允许这两种修改：不仅数据是默认不可变的，而且在数据结构本身一旦在实例化之后也没有改变。

```js
var list1 = Immutable.List.of(1, 2);
// 我们需要通过返回值来获取结果：
// list1没有被修改！
var list2 = list1.push(3, 4, 5);
```

有趣的优势便体现出来了，因为开发者（编译器/运行时）能够确定数据不能修改，所以：

+ 为多线程加锁不再是一个问题：当数据不可变时，再也不需要使用锁来保持多线程的同步了。
+ 持久化（下面将提到的一个重要概念）变得容易。
+ 拷贝变成了一个常量时间的操作：拷贝只是简单的为已存在的数据结构创建一个新的引用。
+ 值比较在特定的情况下可以被简化：此时运行时或编译器能确保，一个特定的实例只有在指向相同的引用时才会是相等的，便能通过引用比较来替代深层比较。这通常只可用在编译或者加载时数据可用的情况下。这样的优化也可以被手动控制（React和Angular就是这样做的，在文章末尾会做出解释）

#### 你已经在使用一个不可变数据结构：String

在javascript中String是不可变的。在String的所有原型方法要么是只读操作，要么返回一个新的String。

一些Javascript运行时使用这个优势来增强性能：在加载或者JIT编译阶段，运行时能把String之间的比较（通常是在字符串字面值之间）简化为引用不叫。你通过一个简单的[JSPerf测试](https://jsperf.com/strinterning/4)看看你的浏览器是否是这样处理的。

![](https://cdn.auth0.com/blog/immutablejs/interning.png)

#### 不可变与Object.freeze()

Javascript是一个动态、弱类型的语言（或者是无类型，如果你熟悉编程语言理论的话）。正因如此，有时难以强制对对象和数据的某些约束。`Object.freeze()`帮我们解决了这个问题。对`Object.freeze`的调用标志着这个对象的所有属性都成为不可变的。对它的修改要么不成功，要么抛出一个异常（在严格模式下）。如果你正写一个不可变对象，在完成初始化之后调用`Object.freeze`能帮上忙。

请牢记`Object.freeze()`是浅操作：这个对象的子对象依然能够被修改。为了解决这个问题，[Mozilla](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)提供了这个函数的一个`deepFreeze`版本，如下：

```js
function deepFreeze(obj) {
    // 取出这个对象中的所有property
    var propNames = Object.getOwnPropertyNames(obj);

    // 在冻结自己之前，先把所有的property冻结
    propNames.forEach(function(name) {
        var prop = obj[name];

        // 如果是一个object，则冻结
        if (typeof prop == 'object' && prop !== null) {        
            deepFreeze(prop);
        }
    });

    // 冻结自己（如果已被冻结则什么也不会发生）
    return Object.freeze(obj);
}
```

### 副作用

在编程语言理论中，对任意操作（通常是一个函数或者方法调用）的副作用是指可以在这个函数外部被观察到的改变。换句话来说，就是能够在调用后找到状态中的变化。每一个调用都会改变一些状态。与“不可变”的概念作对比，“不可变”通常与数据或者数据结构有联系，而副作用通常与整个程序的状态有关联。保护一个数据结构实例的函数会导致副作用发生。缓存函数（caching functions)或者说记忆函数（memoization）便是这样一个很好的例子。即使对于外部观察者来说这好像不会导致什么改变发生，但是更新一个全局或者局部缓存会更新其内部数据结构，以便让缓存起效，而这也是一个副作用（让运算加速也算是一个副作用）。开发者们需要注意到这些副作用并且合适地处理这些问题。

举个缓存的例子：一个不可变数据结构有一个作为前端的缓存，那么它将不能自由地传递到不同的线程中。这个缓存必须要支持多线程，否则将得到不可预知的结果。

函数式编程范式喜欢使用无副作用的函数。函数必须只对传入给自身的数据进行操作，并且这个操作的修改只能被调用者发现。不可变数据结构调用一个接一个的无副作用函数。

```js
var globalCounter = 99;

// 这个函数改变了全局状态
function add(a, b) {
    ++globalCounter;
    return a + b;
}

// 上面那个看起来无辜的add函数调用可能会对
// 这个控制台的打印结果产生异常的修改
function printCounter() {
    console.log(globalCounter.toString());
}
```

#### 纯

纯是一个可以被强加在函数中的附加条件：纯函数只依赖那些明确作为参数传入的参数来产生一个结果。换种说法，纯函数一定不能依赖全局状态或者可通过其他方式来访问的状态。

```js
var globalValue = 99;

// 这个函数是不纯的：如果globalValue改变，它的结果也会发生改变，
// 即使传入的值a和b与之前的相同。
function sum(a, b) {
    return a + b + globalValue;
}
```

#### 引用透明

一个具有无副作用的纯函数是引用透明的。